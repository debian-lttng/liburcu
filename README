Userspace RCU Implementation
by Mathieu Desnoyers and Paul E. McKenney

BUILDING
--------

	./bootstrap (skip if using tarball)
	./configure
	make
	make install

	Hints:	Forcing 32-bit build:
		* CFLAGS="-m32 -g -O2" ./configure

		Forcing 64-bit build:
		* CFLAGS="-m64 -g -O2" ./configure

		Forcing a 32-bit build with 386 backward compatibility:
		* CFLAGS="-m32 -g -O2" ./configure --target=i386-pc-linux-gnu

ARCHITECTURES SUPPORTED
-----------------------

Currently, x86 (i386, i486, i586, i686), x86 64-bit, PowerPC 32/64, S390, S390x
and Sparc64 are supported. Only tested on Linux so far, but should
theoretically work on other operating systems.

QUICK START GUIDE
-----------------

Usage of all urcu libraries

	* Define _LGPL_SOURCE (only) if your code is LGPL or GPL compatible
	  before including the urcu.h or urcu-qsbr.h header. If your application
	  is distributed under another license, function calls will be generated
	  instead of inlines, so your application can link with the library.
	* Linking with one of the libraries below is always necessary even for
	  LGPL and GPL applications.

Usage of liburcu

	* #include <urcu.h>
	* Link the application with "-lurcu".
	* This is the preferred version of the library, both in terms of speed
	  and flexibility. Requires a signal, typically SIGUSR1. Can be
	  overridden with -DSIGURCU by modifying Makefile.build.inc.

Usage of liburcu-mb

	* #include <urcu.h>
	* Compile any _LGPL_SOURCE code using this library with "-DURCU_MB".
	* Link with "-lurcu-mb".
	* This version of the urcu library does not need to
	  reserve a signal number. URCU_MB uses full memory barriers for
	  readers. This eliminates the need for signals but results in slower
	  reads.

Usage of liburcu-qsbr

	* #include <urcu-qsbr.h>
	* Link with "-lurcu-qsbr".
	* The QSBR flavor of RCU needs to have each reader thread executing
	  rcu_quiescent_state() periodically to progress. rcu_thread_online()
	  and rcu_thread_offline() can be used to mark long periods for which
	  the threads are not active. It provides the fastest read-side at the
	  expense of more intrusiveness in the application code.

Usage of liburcu-bp

	* #include <urcu-bp.h>
	* Link with "-lurcu-bp".
	* The BP library flavor stands for "bulletproof". It is specifically
	  designed to help tracing library to hook on applications without
	  requiring to modify these applications. urcu_init(),
	  rcu_register_thread() and rcu_unregister_thread() all become nops.
	  The state is dealt with by the library internally at the expense of
	  read-side and write-side performance.

Initialization

	Each thread that has reader critical sections (that uses
	rcu_read_lock()/rcu_read_unlock() must first register to the URCU
	library. This is done by calling rcu_register_thread(). Unregistration
	must be performed before exiting the thread by using
	rcu_unregister_thread().

Reading

	Reader critical sections must be protected by locating them between
	calls to rcu_read_lock() and rcu_read_unlock(). Inside that lock,
	rcu_dereference() may be called to read an RCU protected pointer.

Writing

	rcu_assign_pointer() and rcu_xchg_pointer() may be called anywhere.
	After, synchronize_rcu() must be called. When it returns, the old
	values are not in usage anymore.

Usage of liburcu-defer

	* #include <urcu-defer.h>
	* Link with "-lurcu-defer"
	* Provides defer_rcu() primitive to enqueue delayed callbacks. Queued
	  callbacks are executed in batch periodically after a grace period.
	  Do _not_ use defer_rcu() within a read-side critical section, because
	  it may call synchronize_rcu() if the thread queue is full.
	* Provides defer_rcu_ratelimit() primitive, which acts just like
	  defer_rcu(), but takes an additional rate limiter callback forcing
	  synchronized callback execution of the limiter returns non-zero.
	* Requires that rcu_defer_barrier() must be called in library destructor
	  if a library queues callbacks and is expected to be unloaded with
	  dlclose().
	* Its API is currently experimental. It may change in future library
	  releases.

Being careful with signals

	The liburcu library uses signals internally. The signal handler is
	registered with the SA_RESTART flag. However, these signals may cause
	some non-restartable system calls to fail with errno = EINTR. Care
	should be taken to restart system calls manually if they fail with this
	error. A list of non-restartable system calls may be found in
	signal(7). The liburcu-mb and liburcu-qsbr versions of the Userspace RCU
	library do not require any signal.

	Read-side critical sections are allowed in a signal handler with
	liburcu and liburcu-mb. Be careful, however, to disable these signals
	between thread creation and calls to rcu_register_thread(), because a
	signal handler nesting on an unregistered thread would not be allowed to
	call rcu_read_lock().

	Read-side critical sections are _not_ allowed in a signal handler with
	liburcu-qsbr, unless signals are disabled explicitly around each
	rcu_quiescent_state() calls, when threads are put offline and around
	calls to synchronize_rcu(). Even then, we do not recommend it.

Usage of DEBUG_RCU

	DEBUG_RCU is used to add internal debugging self-checks to the
	RCU library. This define adds a performance penalty when enabled.
	Can be enabled by uncommenting the corresponding line in
	Makefile.build.inc.

Usage of DEBUG_YIELD

	DEBUG_YIELD is used to add random delays in the code for testing
	purposes.

SMP support

	By default the library is configured to use synchronization primitives
	adequate for SMP systems. On uniprocessor systems, support for SMP
	systems can be disabled with:

		./configure --disable-smp-support

	theoretically yielding slightly better performance.
